<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Leaflet Story Demo with Linked Chapters & Markers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #222;
      background: #f5f5f5;
    }

    .app {
      display: flex;
      height: 100vh;
      overflow: hidden;
      opacity: 0;              /* hidden until warm-up complete */
      transition: opacity 0.4s ease;
    }

    .app.app-ready {
      opacity: 1;
    }

    /* Fullscreen loader */
    #loader {
      position: fixed;
      inset: 0;
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-size: 1.1rem;
      color: #333;
    }

    .loader-inner {
      text-align: center;
    }
    .loader-spinner {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 4px solid #ddd;
      border-top-color: #333;
      animation: spin 0.8s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .narrative {
      width: 40%;
      max-width: 520px;
      min-width: 320px;
      overflow-y: auto;
      padding: 1.5rem 1.5rem 3rem;
      background: #ffffff;
      box-shadow: 2px 0 6px rgba(0, 0, 0, 0.1);
      scroll-behavior: smooth;

      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .narrative::-webkit-scrollbar {
      display: none;
    }

    .narrative-header {
      margin-bottom: 1.5rem;
      border-bottom: 1px solid #ddd;
      padding-bottom: 0.75rem;
    }
    .narrative-header h1 {
      margin: 0 0 0.25rem;
      font-size: 1.6rem;
    }
    .narrative-header p {
      margin: 0;
      font-size: 0.95rem;
      color: #666;
    }
    .chapter {
      margin-bottom: 2.5rem;
      padding: 1rem 0;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      transition: background-color 0.15s ease;
    }
    .chapter:last-child {
      border-bottom: none;
    }
    .chapter:hover {
      background-color: #f7f7f7;
    }

    .chapter h2 {
      margin: 0 0 0.5rem;
      font-size: 1.2rem;
    }
    .chapter .chapter-image {
      width: 100%;
      height: 320px;
      margin: 0.5rem 0 0.75rem;
      background-size: cover;
      background-position: center;
      border-radius: 0;
      background-color: #ddd;
    }
    .chapter p {
      margin: 0 0 0.5rem;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    .chapter.active h2 {
      color: #030303;
    }
    .chapter.active {
      background: #f7f7f7;
    }
    .narrative-spacer {
      height: 20vh;
      min-height: 120px;
      flex: 0 0 auto;
    }
    #map {
      flex: 1;
      height: 100vh;
    }
    @media (max-width: 800px) {
      .app {
        flex-direction: column;
      }
      .narrative {
        width: 100%;
        max-width: none;
        height: 45vh;
      }
      #map {
        height: 55vh;
      }
    }
  </style>
</head>
<body>
  <!-- Loading overlay -->
  <div id="loader">
    <div class="loader-inner">
      <div class="loader-spinner"></div>
      <div>Preparing map…</div>
    </div>
  </div>

  <div class="app" id="app-root">
    <aside class="narrative" id="narrative">
      <header class="narrative-header">
        <h1>Demo Story Map</h1>
        <p>
          A simple scrolling story with placeholder text, images, markers, and a Leaflet map.
        </p>
      </header>
      <div class="narrative-spacer" aria-hidden="true"></div>
    </aside>
    <div id="map"></div>
  </div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // --------------------------------------------------------------------
    // JSON-style config: only source of content
    // --------------------------------------------------------------------
    const storyConfig = {
      title: "Hedgerow Marathon story map - conceptual demo",
      subtitle:
        "A simple scrolling story map tour: geo-located points on a dynamic map, each associated with media comprising of image and text.",
      mapDefaults: {
        center: [52.8, 0.7],
        zoom: 11
      },
      chapters: [
        {
          id: "chapter1",
          title: "Hedge 1",
          imageUrl: "https://upload.wikimedia.org/wikipedia/commons/6/65/Flowering_gorse_in_hedgerow_-_geograph.org.uk_-_1151811.jpg",
          paragraphs: [
            "Hedgerows in Norfolk are vital ribbons of habitat threading through an intensively farmed landscape, providing food, shelter and nesting sites for farmland birds, small mammals and countless insects while linking up woods, ponds and grasslands as safe wildlife corridors. They also help protect Norfolk’s light soils from erosion, slow down run-off and filter water, and, as living historic boundaries, they shape the character of lanes and fields, making their careful protection and sympathetic management a key part of nature recovery in the county.",
            "Photo credit: Evelyn Simak / Hedgerow and trees / CC BY-SA 2.0"
          ],
          lat: 52.709783,
          lng: 0.580902,
          zoom: 12,
          markerLabel: "Hedge 1"
        },
        {
          id: "chapter2",
          title: "Hedge 2",
          imageUrl: "https://upload.wikimedia.org/wikipedia/commons/6/69/Hedgerow_separating_fields_-_geograph.org.uk_-_715273.jpg",
          paragraphs: [
            "Hedgerows in Norfolk are vital ribbons of habitat threading through an intensively farmed landscape, providing food, shelter and nesting sites for farmland birds, small mammals and countless insects while linking up woods, ponds and grasslands as safe wildlife corridors. They also help protect Norfolk’s light soils from erosion, slow down run-off and filter water, and, as living historic boundaries, they shape the character of lanes and fields, making their careful protection and sympathetic management a key part of nature recovery in the county.",
            "Photo credit: Evelyn Simak / Hedgerow and trees / CC BY-SA 2.0"
          ],
          lat: 52.77461,
          lng: 0.604248,
          zoom: 12,
          markerLabel: "Hedge 2"
        },
        {
          id: "chapter3",
          title: "Hedge 3",
          imageUrl: "https://upload.wikimedia.org/wikipedia/commons/4/4d/Field_and_hedgerow%2C_Harling_-_geograph.org.uk_-_7915932.jpg",
          paragraphs: [
            "Hedgerows in Norfolk are vital ribbons of habitat threading through an intensively farmed landscape, providing food, shelter and nesting sites for farmland birds, small mammals and countless insects while linking up woods, ponds and grasslands as safe wildlife corridors. They also help protect Norfolk’s light soils from erosion, slow down run-off and filter water, and, as living historic boundaries, they shape the character of lanes and fields, making their careful protection and sympathetic management a key part of nature recovery in the county.",
            "Photo credit: Evelyn Simak / Hedgerow and trees / CC BY-SA 2.0"
          ],
          lat: 52.836439,
          lng: 0.637894,
          zoom: 12,
          markerLabel: "Hedge 3"
        },
        {
          id: "chapter4",
          title: "Hedge 4",
          imageUrl: "https://upload.wikimedia.org/wikipedia/commons/4/42/Hedgerow_south_of_Paston_Green_-_geograph.org.uk_-_5886102.jpg",
          paragraphs: [
            "Hedgerows in Norfolk are vital ribbons of habitat threading through an intensively farmed landscape, providing food, shelter and nesting sites for farmland birds, small mammals and countless insects while linking up woods, ponds and grasslands as safe wildlife corridors. They also help protect Norfolk’s light soils from erosion, slow down run-off and filter water, and, as living historic boundaries, they shape the character of lanes and fields, making their careful protection and sympathetic management a key part of nature recovery in the county.",
            "Photo credit: Evelyn Simak / Hedgerow and trees / CC BY-SA 2.0"
          ],
          lat: 52.889897,
          lng: 0.714798,
          zoom: 12,
          markerLabel: "Hedge 4"
        },
        {
          id: "chapter5",
          title: "Hedge 5",
          imageUrl: "https://upload.wikimedia.org/wikipedia/commons/e/eb/Neatly_trimmed_hedgerows_-_geograph.org.uk_-_615043.jpg",
          paragraphs: [
            "Hedgerows in Norfolk are vital ribbons of habitat threading through an intensively farmed landscape, providing food, shelter and nesting sites for farmland birds, small mammals and countless insects while linking up woods, ponds and grasslands as safe wildlife corridors. They also help protect Norfolk’s light soils from erosion, slow down run-off and filter water, and, as living historic boundaries, they shape the character of lanes and fields, making their careful protection and sympathetic management a key part of nature recovery in the county.",
            "Photo credit: Evelyn Simak / Hedgerow and trees / CC BY-SA 2.0"
          ],
          lat: 52.938764,
          lng: 0.778656,
          zoom: 12,
          markerLabel: "Hedge 5"
        }
      ]
    };

    // --------------------------------------------------------------------
    // Apply config to the DOM BEFORE original logic
    // --------------------------------------------------------------------
    const narrativeEl = document.getElementById("narrative");
    const headerTitleEl = narrativeEl.querySelector(".narrative-header h1");
    const headerSubtitleEl = narrativeEl.querySelector(".narrative-header p");
    if (headerTitleEl) headerTitleEl.textContent = storyConfig.title;
    if (headerSubtitleEl) headerSubtitleEl.textContent = storyConfig.subtitle;
    const spacerEl = narrativeEl.querySelector(".narrative-spacer");

    storyConfig.chapters.forEach((cfg) => {
      const section = document.createElement("section");
      section.className = "chapter";
      section.setAttribute("data-chapter-id", cfg.id);

      const h2 = document.createElement("h2");
      h2.textContent = cfg.title;
      section.appendChild(h2);

      const imgDiv = document.createElement("div");
      imgDiv.className = "chapter-image";
      imgDiv.style.backgroundImage = `url('${cfg.imageUrl}')`;
      section.appendChild(imgDiv);

      cfg.paragraphs.forEach((text) => {
        const p = document.createElement("p");
        p.textContent = text;
        section.appendChild(p);
      });

      narrativeEl.insertBefore(section, spacerEl);
    });

    const chapterEls = Array.from(document.querySelectorAll(".chapter"));

    const chapters = {};
    storyConfig.chapters.forEach((cfg) => {
      chapters[cfg.id] = {
        center: [cfg.lat, cfg.lng],
        zoom: cfg.zoom,
        label: cfg.markerLabel
      };
    });

    // --------------------------------------------------------------------
    // MAP + MASK + LINE IMPLEMENTATION
    // --------------------------------------------------------------------

    const map = L.map("map", {
      center: storyConfig.mapDefaults.center,
      zoom: storyConfig.mapDefaults.zoom,
      scrollWheelZoom: false
    });

    const mapContainer = document.getElementById("map");
    mapContainer.addEventListener("wheel", (event) => {
      narrativeEl.scrollTop += event.deltaY;
    });

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap contributors",
      maxZoom: 19,
    }).addTo(map);

    map.createPane("maskPane");
    map.getPane("maskPane").style.zIndex = 450;

    const maskRenderer = L.svg({ padding: 1 });

    const boundaryUrl =
      "https://firebasestorage.googleapis.com/v0/b/naturecitynorwich.firebasestorage.app/o/Assets%2FhedgerowMarathonSimpleLine_buffer.geojson?alt=media&token=b6161307-c07a-4b66-8c8e-8301ba37d733";

    const lineUrl =
      "https://firebasestorage.googleapis.com/v0/b/naturecitynorwich.firebasestorage.app/o/Assets%2FhedgerowMarathonSimpleLine.geojson?alt=media&token=06a245dd-6656-4c92-a26e-7574c8549206";

    const boundaryPromise = fetch(boundaryUrl)
      .then((r) => {
        if (!r.ok) throw new Error(r.status);
        return r.json();
      })
      .then((geoJsonData) => {
        const boundaryFeature =
          geoJsonData.type === "FeatureCollection"
            ? geoJsonData.features[0]
            : geoJsonData;

        const boundaryGeom = boundaryFeature.geometry;

        const worldRectangle = [
          [-180, -90],
          [-180, 90],
          [180, 90],
          [180, -90],
          [-180, -90]
        ];

        let maskPolygons;
        if (boundaryGeom.type === "Polygon") {
          maskPolygons = [boundaryGeom.coordinates];
        } else if (boundaryGeom.type === "MultiPolygon") {
          maskPolygons = boundaryGeom.coordinates;
        } else {
          throw new Error("Unsupported geometry for mask");
        }

        const invertedMaskGeoJson = {
          type: "Feature",
          geometry: {
            type: "MultiPolygon",
            coordinates: [
              [worldRectangle],
              ...maskPolygons
            ]
          }
        };

        L.geoJSON(invertedMaskGeoJson, {
          style: {
            fillColor: "white",
            fillOpacity: 0.85,
            stroke: false,
            fillRule: "evenodd",
            interactive: false
          },
          pane: "maskPane",
          renderer: maskRenderer
        }).addTo(map);

        const boundaryLayer = L.geoJSON(boundaryFeature);
        map.fitBounds(boundaryLayer.getBounds());
      })
      .catch((err) => console.error("Boundary/mask error:", err));

    const linePromise = fetch(lineUrl)
      .then((r) => {
        if (!r.ok) throw new Error(r.status);
        return r.json();
      })
      .then((lineGeoJson) => {
        L.geoJSON(lineGeoJson, {
          style: {
            color: "#ff0000",
            weight: 4
          }
        }).addTo(map);
      })
      .catch((err) => console.error("Line error:", err));

    // Warm up tiles for all chapter views (invisible to user)
    function warmUpTilesThenShow() {
      const loaderEl = document.getElementById("loader");
      const appRoot = document.getElementById("app-root");

      // first chapter as visible starting point
      const firstChapter = storyConfig.chapters[0];
      const finalCenter = [firstChapter.lat, firstChapter.lng];
      const finalZoom = firstChapter.zoom;

      let i = 0;

      function step() {
        if (i >= storyConfig.chapters.length) {
          // restore to first chapter view (still hidden)
          map.setView(finalCenter, finalZoom, { animate: false });

          // small delay to let final tiles finish
          setTimeout(() => {
            loaderEl.style.display = "none";
            appRoot.classList.add("app-ready");
            // now map is visible: start story at chapter1 with flyTo
            setActiveChapter(firstChapter.id);
          }, 200);

          return;
        }

        const ch = storyConfig.chapters[i];
        // invisible, no animation; solely for tile warm-up
        map.setView([ch.lat, ch.lng], ch.zoom, { animate: false });
        i += 1;
        setTimeout(step, 120);
      }

      step();
    }

    Promise.all([boundaryPromise, linePromise]).then(() => {
      warmUpTilesThenShow();
    });

    // --------------------------------------------------------------------
    // MARKERS + STORY INTERACTION (ALWAYS ANIMATED)
    // --------------------------------------------------------------------

    const markers = {};
    Object.entries(chapters).forEach(([id, cfg]) => {
      const marker = L.marker(cfg.center)
        .addTo(map)
        .bindPopup(`<strong>${cfg.label}</strong>`);

      marker.on("click", () => {
        const chapterEl = document.querySelector(
          `.chapter[data-chapter-id="${id}"]`
        );
        if (chapterEl) {
          setActiveChapter(id);
          scrollChapterIntoView(chapterEl);
        }
      });

      markers[id] = marker;
    });

    let activeChapterId = null;

    let isFlying = false;
    let pendingChapterId = null;

    map.on("moveend", () => {
      isFlying = false;
      if (pendingChapterId) {
        const nextId = pendingChapterId;
        pendingChapterId = null;
        setActiveChapter(nextId);
      }
    });

    function setActiveChapter(chapterId) {
      if (chapterId === activeChapterId) return;

      // If a flyTo is in progress, queue the latest requested chapter
      if (isFlying) {
        pendingChapterId = chapterId;
        return;
      }

      activeChapterId = chapterId;

      chapterEls.forEach((el) => el.classList.remove("active"));
      const chapterEl = document.querySelector(
        `.chapter[data-chapter-id="${chapterId}"]`
      );
      if (chapterEl) {
        chapterEl.classList.add("active");
      }

      const cfg = chapters[chapterId];
      if (cfg) {
        isFlying = true;
        map.flyTo(cfg.center, cfg.zoom, {
          duration: 1.0
        });
      }

      Object.values(markers).forEach((m) => m.closePopup());
      if (markers[chapterId]) {
        markers[chapterId].openPopup();
      }
    }

    function scrollChapterIntoView(chapterEl) {
      const containerRect = narrativeEl.getBoundingClientRect();
      const chapterRect = chapterEl.getBoundingClientRect();
      const offset =
        chapterRect.top -
        containerRect.top -
        containerRect.height / 2 +
        chapterRect.height / 2;

      narrativeEl.scrollTop += offset;
    }

    narrativeEl.addEventListener("scroll", () => {
      const containerRect = narrativeEl.getBoundingClientRect();
      const containerCenterY = containerRect.top + containerRect.height / 2;

      let bestChapterId = null;
      let bestDistance = Infinity;

      chapterEls.forEach((el) => {
        const rect = el.getBoundingClientRect();
        const chapterCenterY = rect.top + rect.height / 2;

        if (rect.bottom < containerRect.top || rect.top > containerRect.bottom) {
          return;
        }

        const distance = Math.abs(chapterCenterY - containerCenterY);
        if (distance < bestDistance) {
          bestDistance = distance;
          bestChapterId = el.getAttribute("data-chapter-id");
        }
      });

      if (bestChapterId) {
        setActiveChapter(bestChapterId);
      }
    });

    chapterEls.forEach((chapter) => {
      chapter.addEventListener("click", () => {
        const chapterId = chapter.getAttribute("data-chapter-id");
        setActiveChapter(chapterId);
        scrollChapterIntoView(chapter);
      });
    });

    // No initial setActiveChapter call here; first call happens after warm-up.
  </script>
</body>
</html>
